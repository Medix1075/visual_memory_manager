<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Management Simulator - Visual Toy Chest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #e0e0e0;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Toy Chest Visualization */
        .toy-chest {
            background: #fff;
            border: 3px solid #8b4513;
            border-radius: 8px;
            padding: 10px;
            min-height: 300px;
        }

        .memory-blocks {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .memory-block {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 5px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .memory-block.free {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px dashed #4caf50;
        }

        .memory-block.used {
            background: linear-gradient(135deg, #fff3e0 0%, #ffcc80 100%);
            border: 2px solid #ff9800;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .block-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
            font-size: 0.9em;
        }

        .block-label {
            font-weight: bold;
        }

        .block-size {
            background: rgba(255,255,255,0.7);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.85em;
        }

        .toy-icon {
            margin-right: 10px;
            font-size: 1.5em;
        }

        /* Terminal */
        .terminal {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .terminal-output {
            color: #00ff00;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }

        .terminal-error {
            color: #ff4444;
        }

        .terminal-success {
            color: #44ff44;
        }

        .terminal-info {
            color: #44ccff;
        }

        .terminal-input-line {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .terminal-prompt {
            color: #00ff00;
            font-weight: bold;
        }

        .terminal input {
            flex: 1;
            background: #2d2d2d;
            border: 1px solid #444;
            color: #00ff00;
            padding: 8px;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            outline: none;
        }

        .terminal input:focus {
            border-color: #00ff00;
        }

        /* Control Panel */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.85em;
            font-weight: bold;
            color: #555;
        }

        .control-group input,
        .control-group select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        /* Stats Panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            margin: 5px 0;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
        }

        .progress-bar {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75em;
            font-weight: bold;
        }

        /* Quick Commands */
        .quick-commands {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .quick-cmd {
            background: #f0f0f0;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            border: 1px solid #ddd;
            transition: all 0.2s;
        }

        .quick-cmd:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .emoji {
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß∏ Memory Management Simulator - Visual Toy Chest</h1>
        <p class="subtitle">Watch how memory allocation works in real-time!</p>

        <div class="main-layout">
            <!-- Left Side: Visual Toy Chest -->
            <div class="section">
                <h2><span class="emoji">üì¶</span> Toy Chest (Memory Layout)</h2>
                <div class="toy-chest">
                    <div id="memoryBlocks" class="memory-blocks">
                        <div class="memory-block free">
                            <span class="toy-icon">üì≠</span>
                            <div class="block-info">
                                <span class="block-label">Empty Toy Chest</span>
                                <span class="block-size">Initialize memory first!</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Side: Terminal -->
            <div class="section">
                <h2><span class="emoji">üíª</span> Command Terminal</h2>
                <div class="terminal" id="terminal">
                    <div class="terminal-output terminal-info">Welcome to Memory Manager! üéÆ
Type commands below or use quick buttons.

Quick Start:
1. init memory 1024
2. malloc 100
3. malloc 200

Type 'help' for all commands.</div>
                    <div class="terminal-input-line">
                        <span class="terminal-prompt">></span>
                        <input type="text" id="commandInput" placeholder="Type command here..." autocomplete="off">
                    </div>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="section">
            <h2><span class="emoji">üéõÔ∏è</span> Quick Controls</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Memory Size:</label>
                    <input type="number" id="memSize" value="1024" min="256" step="256">
                </div>
                <div class="control-group">
                    <label>Allocation Strategy:</label>
                    <select id="strategy">
                        <option value="first_fit">First Fit</option>
                        <option value="best_fit">Best Fit</option>
                        <option value="worst_fit">Worst Fit</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Allocate Size:</label>
                    <input type="number" id="allocSize" value="100" min="1">
                </div>
                <div class="control-group">
                    <label>Free Block ID:</label>
                    <input type="number" id="freeId" value="1" min="1">
                </div>
            </div>
            <div class="quick-commands">
                <button class="quick-cmd" onclick="quickInit()">üöÄ Init Memory</button>
                <button class="quick-cmd" onclick="quickMalloc()">‚ûï Allocate</button>
                <button class="quick-cmd" onclick="quickFree()">‚ûñ Free</button>
                <button class="quick-cmd" onclick="quickStats()">üìä Stats</button>
                <button class="quick-cmd" onclick="quickClear()">üßπ Clear Terminal</button>
                <button class="quick-cmd" onclick="quickDemo()">üé¨ Run Demo</button>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="section">
            <h2><span class="emoji">üìä</span> Memory Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Memory</div>
                    <div class="stat-value" id="statTotal">0</div>
                    <div style="font-size: 0.75em; color: #999;">bytes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Used Memory</div>
                    <div class="stat-value" id="statUsed">0</div>
                    <div style="font-size: 0.75em; color: #999;">bytes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Free Memory</div>
                    <div class="stat-value" id="statFree">0</div>
                    <div style="font-size: 0.75em; color: #999;">bytes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Fragmentation</div>
                    <div class="stat-value" id="statFrag">0%</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
        </div>
    </div>

    <script>
        // Memory Management System
        class MemoryBlock {
            constructor(start, size, isFree, id = null) {
                this.start = start;
                this.size = size;
                this.isFree = isFree;
                this.id = id;
            }
        }

        class MemoryManager {
            constructor() {
                this.blocks = [];
                this.totalSize = 0;
                this.nextId = 1;
                this.strategy = 'first_fit';
                this.allocations = 0;
                this.deallocations = 0;
            }

            init(size) {
                this.totalSize = size;
                this.blocks = [new MemoryBlock(0, size, true)];
                this.nextId = 1;
                this.allocations = 0;
                this.deallocations = 0;
            }

            setStrategy(strategy) {
                this.strategy = strategy;
            }

            malloc(size) {
                if (size <= 0) return null;

                let blockIndex = -1;
                let suitableBlock = null;

                if (this.strategy === 'first_fit') {
                    for (let i = 0; i < this.blocks.length; i++) {
                        if (this.blocks[i].isFree && this.blocks[i].size >= size) {
                            blockIndex = i;
                            suitableBlock = this.blocks[i];
                            break;
                        }
                    }
                } else if (this.strategy === 'best_fit') {
                    let bestSize = Infinity;
                    for (let i = 0; i < this.blocks.length; i++) {
                        if (this.blocks[i].isFree && this.blocks[i].size >= size && this.blocks[i].size < bestSize) {
                            blockIndex = i;
                            suitableBlock = this.blocks[i];
                            bestSize = this.blocks[i].size;
                        }
                    }
                } else if (this.strategy === 'worst_fit') {
                    let worstSize = -1;
                    for (let i = 0; i < this.blocks.length; i++) {
                        if (this.blocks[i].isFree && this.blocks[i].size >= size && this.blocks[i].size > worstSize) {
                            blockIndex = i;
                            suitableBlock = this.blocks[i];
                            worstSize = this.blocks[i].size;
                        }
                    }
                }

                if (!suitableBlock) return null;

                const blockId = this.nextId++;

                if (suitableBlock.size === size) {
                    suitableBlock.isFree = false;
                    suitableBlock.id = blockId;
                } else {
                    const newFreeBlock = new MemoryBlock(
                        suitableBlock.start + size,
                        suitableBlock.size - size,
                        true
                    );
                    suitableBlock.size = size;
                    suitableBlock.isFree = false;
                    suitableBlock.id = blockId;
                    this.blocks.splice(blockIndex + 1, 0, newFreeBlock);
                }

                this.allocations++;
                return { id: blockId, address: suitableBlock.start };
            }

            free(blockId) {
                let blockIndex = -1;
                for (let i = 0; i < this.blocks.length; i++) {
                    if (!this.blocks[i].isFree && this.blocks[i].id === blockId) {
                        blockIndex = i;
                        break;
                    }
                }

                if (blockIndex === -1) return false;

                this.blocks[blockIndex].isFree = true;
                this.blocks[blockIndex].id = null;
                this.deallocations++;

                this.coalesce(blockIndex);
                return true;
            }

            coalesce(index) {
                while (index < this.blocks.length - 1) {
                    if (this.blocks[index].isFree && this.blocks[index + 1].isFree) {
                        this.blocks[index].size += this.blocks[index + 1].size;
                        this.blocks.splice(index + 1, 1);
                    } else {
                        break;
                    }
                }

                while (index > 0) {
                    if (this.blocks[index - 1].isFree && this.blocks[index].isFree) {
                        this.blocks[index - 1].size += this.blocks[index].size;
                        this.blocks.splice(index, 1);
                        index--;
                    } else {
                        break;
                    }
                }
            }

            getStats() {
                const used = this.blocks.filter(b => !b.isFree).reduce((sum, b) => sum + b.size, 0);
                const free = this.totalSize - used;
                const freeBlocks = this.blocks.filter(b => b.isFree);
                const largestFree = freeBlocks.length > 0 ? Math.max(...freeBlocks.map(b => b.size)) : 0;
                const externalFrag = free > 0 ? ((free - largestFree) / this.totalSize * 100) : 0;

                return {
                    total: this.totalSize,
                    used: used,
                    free: free,
                    utilization: this.totalSize > 0 ? (used / this.totalSize * 100) : 0,
                    fragmentation: externalFrag,
                    allocations: this.allocations,
                    deallocations: this.deallocations
                };
            }
        }

        // UI Controller
        const memory = new MemoryManager();
        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('commandInput');

        const toyIcons = ['üß∏', 'üöó', 'üé®', 'üìö', 'üéÆ', 'üé∏', '‚öΩ', 'üé≤', 'ü™Ä', 'üéØ'];

        function getToyIcon(id) {
            return toyIcons[id % toyIcons.length];
        }

        function visualizeMemory() {
            const container = document.getElementById('memoryBlocks');
            container.innerHTML = '';

            if (memory.blocks.length === 0) {
                container.innerHTML = '<div class="memory-block free"><span class="toy-icon">üì≠</span><div class="block-info"><span class="block-label">No Memory Initialized</span></div></div>';
                return;
            }

            memory.blocks.forEach(block => {
                const div = document.createElement('div');
                div.className = `memory-block ${block.isFree ? 'free' : 'used'}`;
                
                const icon = block.isFree ? 'üì≠' : getToyIcon(block.id);
                const label = block.isFree ? 'FREE SPACE' : `TOY #${block.id}`;
                const endAddr = block.start + block.size - 1;
                
                div.innerHTML = `
                    <span class="toy-icon">${icon}</span>
                    <div class="block-info">
                        <span class="block-label">${label}</span>
                        <span class="block-size">[0x${block.start.toString(16).toUpperCase()} - 0x${endAddr.toString(16).toUpperCase()}] ${block.size} bytes</span>
                    </div>
                `;
                
                container.appendChild(div);
            });
        }

        function updateStats() {
            const stats = memory.getStats();
            document.getElementById('statTotal').textContent = stats.total;
            document.getElementById('statUsed').textContent = stats.used;
            document.getElementById('statFree').textContent = stats.free;
            document.getElementById('statFrag').textContent = stats.fragmentation.toFixed(1) + '%';
            
            const utilization = stats.utilization.toFixed(1);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = utilization + '%';
            progressBar.textContent = utilization + '%';
        }

        function addTerminalOutput(text, className = '') {
            const output = document.createElement('div');
            output.className = `terminal-output ${className}`;
            output.textContent = text;
            terminal.insertBefore(output, terminal.querySelector('.terminal-input-line'));
            terminal.scrollTop = terminal.scrollHeight;
        }

        function processCommand(cmd) {
            const parts = cmd.trim().split(/\s+/);
            const command = parts[0].toLowerCase();

            addTerminalOutput(`> ${cmd}`, 'terminal-info');

            if (command === 'help') {
                addTerminalOutput(`Available Commands:
init memory <size> - Initialize memory
malloc <size> - Allocate memory
free <id> - Free memory block
stats - Show statistics
clear - Clear terminal
demo - Run demo`, 'terminal-success');
            }
            else if (command === 'init' && parts[1] === 'memory') {
                const size = parseInt(parts[2]);
                memory.init(size);
                addTerminalOutput(`‚úì Memory initialized: ${size} bytes`, 'terminal-success');
                visualizeMemory();
                updateStats();
            }
            else if (command === 'set' && parts[1] === 'allocator') {
                memory.setStrategy(parts[2]);
                addTerminalOutput(`‚úì Strategy set to: ${parts[2]}`, 'terminal-success');
            }
            else if (command === 'malloc') {
                const size = parseInt(parts[1]);
                const result = memory.malloc(size);
                if (result) {
                    addTerminalOutput(`‚úì Allocated block id=${result.id} at address=0x${result.address.toString(16).toUpperCase()}`, 'terminal-success');
                    visualizeMemory();
                    updateStats();
                } else {
                    addTerminalOutput(`‚úó Allocation failed: Not enough memory!`, 'terminal-error');
                }
            }
            else if (command === 'free') {
                const id = parseInt(parts[1]);
                if (memory.free(id)) {
                    addTerminalOutput(`‚úì Block ${id} freed and merged`, 'terminal-success');
                    visualizeMemory();
                    updateStats();
                } else {
                    addTerminalOutput(`‚úó Block ${id} not found`, 'terminal-error');
                }
            }
            else if (command === 'stats') {
                const stats = memory.getStats();
                addTerminalOutput(`Statistics:
Total: ${stats.total} bytes
Used: ${stats.used} bytes
Free: ${stats.free} bytes
Utilization: ${stats.utilization.toFixed(2)}%
Fragmentation: ${stats.fragmentation.toFixed(2)}%
Allocations: ${stats.allocations}
Deallocations: ${stats.deallocations}`, 'terminal-success');
            }
            else if (command === 'clear') {
                const outputs = terminal.querySelectorAll('.terminal-output');
                outputs.forEach(output => output.remove());
            }
            else if (command === 'demo') {
                runDemo();
            }
            else {
                addTerminalOutput(`‚úó Unknown command: ${command}`, 'terminal-error');
            }
        }

        commandInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const cmd = commandInput.value;
                if (cmd.trim()) {
                    processCommand(cmd);
                    commandInput.value = '';
                }
            }
        });

        // Quick action functions
        function quickInit() {
            const size = document.getElementById('memSize').value;
            processCommand(`init memory ${size}`);
        }

        function quickMalloc() {
            const size = document.getElementById('allocSize').value;
            processCommand(`malloc ${size}`);
        }

        function quickFree() {
            const id = document.getElementById('freeId').value;
            processCommand(`free ${id}`);
        }

        function quickStats() {
            processCommand('stats');
        }

        function quickClear() {
            processCommand('clear');
        }

        function runDemo() {
            const commands = [
                'init memory 1024',
                'malloc 100',
                'malloc 200',
                'malloc 150',
                'malloc 80',
                'free 2',
                'malloc 50',
                'stats'
            ];

            let i = 0;
            const interval = setInterval(() => {
                if (i < commands.length) {
                    processCommand(commands[i]);
                    i++;
                } else {
                    clearInterval(interval);
                }
            }, 1000);
        }

        function quickDemo() {
            if (confirm('This will run a demo sequence. Continue?')) {
                runDemo();
            }
        }

        // Initialize with empty state
        visualizeMemory();
        updateStats();
    </script>
</body>
</html>